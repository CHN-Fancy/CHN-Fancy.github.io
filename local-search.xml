<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32中断控制</title>
    <link href="/2020/09/01/STM32%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/09/01/STM32%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="1、分类："><a href="#1、分类：" class="headerlink" title="1、分类："></a>1、分类：</h2><p>1、内核中断；</p><p><img src="https://s1.ax1x.com/2020/09/02/dzTnbR.png" srcset="/img/loading.gif" alt="dzTnbR.png"></p><p>2、外部中断（可屏蔽中断）</p><p><img src="https://s1.ax1x.com/2020/09/02/dzTaVI.png" srcset="/img/loading.gif" alt="dzTaVI.png"></p><h2 id="2、中断管理方法"><a href="#2、中断管理方法" class="headerlink" title="2、中断管理方法"></a>2、中断管理方法</h2><p>​        对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p><p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p><table><thead><tr><th align="center">组</th><th align="center">AIRCR[10:8]</th><th align="center">IP bit[7:4]</th><th align="center">分配结果</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">111</td><td align="center">0:4</td><td align="center">0位抢占优先级，4位响应优先级</td></tr><tr><td align="center">1</td><td align="center">110</td><td align="center">1:3</td><td align="center">1位抢占优先级，3位响应优先级</td></tr><tr><td align="center">2</td><td align="center">101</td><td align="center">2:2</td><td align="center">2位抢占优先级，2位响应优先级</td></tr><tr><td align="center">3</td><td align="center">100</td><td align="center">3:1</td><td align="center">3位抢占优先级，1位响应优先级</td></tr><tr><td align="center">4</td><td align="center">011</td><td align="center">4:0</td><td align="center">4位抢占优先级，0位响应优先级</td></tr></tbody></table><p>IP bit一共有4位所以一共可以给出16种不同的组合（级别）。</p><h2 id="3、优先级规则"><a href="#3、优先级规则" class="headerlink" title="3、优先级规则"></a>3、优先级规则</h2><ul><li>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。</li><li>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。（抢占优先级只负责打断进程，响应优先级只负责在两个中断同时发生的时候在抢占优先级相同的情况下哪个先执行，所以响应优先级高的不可进行打断）</li><li>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。</li><li>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</li></ul><p><strong>优先级的值越低，优先级的级别越高</strong>。</p><h3 id="举个栗："><a href="#举个栗：" class="headerlink" title="举个栗："></a>举个栗：</h3><p>假定设置中断优先级组为2，然后设置</p><table><thead><tr><th align="center">中断</th><th align="center">优先级设置</th></tr></thead><tbody><tr><td align="center">中断3（RTC中断）</td><td align="center">抢占优先级为2，响应优先级为1</td></tr><tr><td align="center">中断6（外部中断0）</td><td align="center">抢占优先级为3，响应优先级为0</td></tr><tr><td align="center">中断7（外部中断1）</td><td align="center">抢占优先级为2，响应优先级为0</td></tr></tbody></table><p>这3个中断的优先级顺序为：<strong>中断7&gt;中断3&gt;中断6</strong></p><h2 id="4、中断的优先级设置"><a href="#4、中断的优先级设置" class="headerlink" title="4、中断的优先级设置"></a>4、中断的优先级设置</h2><table><thead><tr><th align="center">寄存器</th><th align="center"></th></tr></thead><tbody><tr><td align="center">__IO uint8_t IP[240]</td><td align="center">中断优先级控制的寄存器组</td></tr><tr><td align="center">__IO uint32_t ISER[8]</td><td align="center">中断使能寄存器组</td></tr><tr><td align="center">__IO uint32_t ICER[8]</td><td align="center">中断失能寄存器组</td></tr><tr><td align="center">__IO uint32_t ISPR[8]</td><td align="center">中断挂起寄存器组</td></tr><tr><td align="center">__IO uint32_t ICPR[8]</td><td align="center">中断解挂寄存器组</td></tr><tr><td align="center">__IO uint32_t IABR[8]</td><td align="center">中断激活标志位寄存器组</td></tr></tbody></table><p><strong>中断优先级控制的寄存器组</strong>：IP[240]。全称是：Interrupt Priority Registers</p><p>​        240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F40x系列一共82个可屏蔽中断，使用IP[81]~IP[0]。</p><p>​        每个IP寄存器的<strong>高4位用来设置抢占和响应优先级</strong>（根据分组），低4位没有用到。</p><p>设置<strong>优先级</strong>方法：</p><p>​    调用函数</p><pre><code class="C">void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t                                                     PreemptPriority, uint32_t SubPriority);</code></pre><h2 id="5、中断优先级设置步骤"><a href="#5、中断优先级设置步骤" class="headerlink" title="5、中断优先级设置步骤"></a>5、中断优先级设置步骤</h2><ol><li><p>系统运行后在HAL_Init函数中设置中断优先级分组。调用函数：</p><pre><code class="C"> HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);      //中断优先级分组2 整个系统执行过程中，只设置一次中断分组。</code></pre></li><li><p>针对每个中断，设置对应的抢占优先级和响应优先级：</p><pre><code class="C">void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);</code></pre></li><li><p>使能中断通道：</p><pre><code class="C">void HAL_NVIC_EnableIRQ(IRQn_Type IRQn);</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>中断</tag>
      
      <tag>NVIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32位带操作笔记</title>
    <link href="/2020/09/01/STM32%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/09/01/STM32%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="寄存器位带操作"><a href="#寄存器位带操作" class="headerlink" title="寄存器位带操作"></a>寄存器位带操作</h1><h2 id="什么是位带操作？位操作？"><a href="#什么是位带操作？位操作？" class="headerlink" title="什么是位带操作？位操作？"></a>什么是位带操作？位操作？</h2><h3 id="位带操作："><a href="#位带操作：" class="headerlink" title="位带操作："></a>位带操作：</h3><p>​        通过位带区和位带别名区的地址映射关系可以直接访问寄存器的某一位，并向这一位写值（0或1）。</p><h3 id="普通的位操作：（使用“-amp-”，“-”指令来想、实现SRAM区域或者外设存储区进行位操作）"><a href="#普通的位操作：（使用“-amp-”，“-”指令来想、实现SRAM区域或者外设存储区进行位操作）" class="headerlink" title="普通的位操作：（使用“&amp;”，“|”指令来想、实现SRAM区域或者外设存储区进行位操作）"></a>普通的位操作：（使用“&amp;”，“|”指令来想、实现SRAM区域或者外设存储区进行位操作）</h3><p>​        由于STM32是按字节寻址的，所以并不能直接对位进行操作。若要想改变某个寄存器的值，须先通过寄存器的地址找到这个寄存器并读取寄存器的值，然后根据想要的功能修改读到的值，最后再将修改后的值写入寄存器中。</p><h2 id="位带操作的优越性在哪？"><a href="#位带操作的优越性在哪？" class="headerlink" title="位带操作的优越性在哪？"></a>位带操作的优越性在哪？</h2><p>​        相比于普通的位操作来说位带操作少了寄存器的读和修改的步骤，大大提升运行效率。</p><h2 id="什么是位带区什么是位带别名区？"><a href="#什么是位带区什么是位带别名区？" class="headerlink" title="什么是位带区什么是位带别名区？"></a>什么是位带区什么是位带别名区？</h2><h3 id="位带区："><a href="#位带区：" class="headerlink" title="位带区："></a>位带区：</h3><p>​        是寄存器真实存在的区域。每个寄存器都为4个字节（32位）。</p><h3 id="位带别名区："><a href="#位带别名区：" class="headerlink" title="位带别名区："></a>位带别名区：</h3><p>​        是位带区的对应的膨胀区域，可以想象成是一个位带区的映射。位带别名区的某一个字节的地址就对应相应位带区的某一位的地址，对位带别名区的一个字节进行操作就相当于是对位带区中某一位进行操作。</p><h2 id="为什么有的区域不支持位操作？"><a href="#为什么有的区域不支持位操作？" class="headerlink" title="为什么有的区域不支持位操作？"></a>为什么有的区域不支持位操作？</h2><p>​        是由Crotex-M3、C-M4或者其他系统架构所规定的。只要寄存器是属于位带区的，就支持位带操作。Crotex-M3中规定的支持位带操作的区域如下图所示。</p><p><img src="https://s1.ax1x.com/2020/07/27/aPmTBQ.jpg" srcset="/img/loading.gif" alt="aPmTBQ.jpg"></p><p>分两块区域其中一块为SRAM中最低的1M，另一块为外设寄存器中最低的1M。</p><h3 id="位操作支持的区域"><a href="#位操作支持的区域" class="headerlink" title="位操作支持的区域"></a>位操作支持的区域</h3><p>另外在STM32F1xx和STM32F4xx上大部分的外设寄存器都支持位带操作，但少数外设寄存器并不支持位带操作。一位网友的经历，先来一个<a href="http://www.51hei.com/bbs/dpj-51883-1.html" target="_blank" rel="noopener">链接</a>，以防文章被删留图存档。</p><p><img src="https://s1.ax1x.com/2020/07/27/aPupxf.png" srcset="/img/loading.gif" alt="aPupxf.png"></p><h2 id="地址与位的关系（位带区与位带别名区的膨胀关系图）"><a href="#地址与位的关系（位带区与位带别名区的膨胀关系图）" class="headerlink" title="地址与位的关系（位带区与位带别名区的膨胀关系图）"></a>地址与位的关系（位带区与位带别名区的膨胀关系图）</h2><p><img src="https://s1.ax1x.com/2020/07/27/aPuqS0.png" srcset="/img/loading.gif" alt="aPuqS0.png"></p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>GPIO</tag>
      
      <tag>位带操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO的八种工作模式</title>
    <link href="/2020/09/01/GPIO%E7%9A%84%E5%85%AB%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/09/01/GPIO%E7%9A%84%E5%85%AB%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="GPIO的八种工作模式"><a href="#GPIO的八种工作模式" class="headerlink" title="GPIO的八种工作模式"></a>GPIO的八种工作模式</h1><p>​        从GPIO（General-purpose input/output，通用输入/输出端口）的名称就能看出，其工作模式就分为两大类：输入、输出。</p><h2 id="输入模式（4种）"><a href="#输入模式（4种）" class="headerlink" title="输入模式（4种）"></a>输入模式（4种）</h2><table><thead><tr><th align="center">名称</th><th align="center">GPIO配置名称</th></tr></thead><tbody><tr><td align="center">模拟输入</td><td align="center">GPIO_Mode_AIN</td></tr><tr><td align="center">浮空输入</td><td align="center">GPIO_Mode_IN_FLOATING</td></tr><tr><td align="center">上拉输入</td><td align="center">GPIO_Mode_IPU</td></tr><tr><td align="center">下拉输入</td><td align="center">GPIO_Mode_IPD</td></tr></tbody></table><ol><li><p>模拟输入：</p><p>用于采集模拟信号的输入方式（ADC），或者低功耗下省电。</p></li><li><p>浮空输入：</p><p>对于浮空输入模式顾名思义也就是输入什么信号才是什么信号，对于浮空输入要保证有明确的输入信号（TTL或者CMOS标准）</p><blockquote><p>1）TTL</p><p>  供电范围在0~5V；如74系列都是5V供电</p><p>  对输出：大于2.7V是高电平；小于0.5V是低电平</p><p>  对输入：大于2V是高电平；小于0.8V是低电平</p><p>2) 3.3 LVTTL</p><p>  供电电压通常小等于3.3V</p><p>  对输出：大于2.0V是高电平；小于0.2V是低电平</p><p>  对输入：大于1.7V是高电平；小于0.7V是低电平</p><p>​    通常在许多处理器芯片都是用的LVTTL标准。</p></blockquote></li><li><p>上拉输入：</p><p>​    区别在于没有输入信号的时候默认输入高电平（因为有弱上拉）。外界还是可以接入低电平以实现低电平的读取。常用于数据传输线的配置。</p></li><li><p>下拉输入：</p><p>​    区别在于没有输入信号的时候默认输入低电平（因为有弱下拉）。外界还是可以接入高电平以实现高电平的读取。也常用于数据传输线的配置。</p></li></ol><h2 id="输出模式（4种）"><a href="#输出模式（4种）" class="headerlink" title="输出模式（4种）"></a>输出模式（4种）</h2><table><thead><tr><th align="center">名称</th><th align="center">GPIO配置名称</th></tr></thead><tbody><tr><td align="center">开漏输出</td><td align="center">GPIO_Mode_Out_OD</td></tr><tr><td align="center">推挽输出</td><td align="center">GPIO_Mode_Out_PP</td></tr><tr><td align="center">复用开漏输出</td><td align="center">GPIO_Mode_AF_OD</td></tr><tr><td align="center">复用推挽输出</td><td align="center">GPIO_Mode_AF_PP</td></tr></tbody></table><ol><li><p>开漏输出</p><p>​        输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).</p><p>​        OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。</p><p>​        可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。可以理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。</p></li><li><p>推挽输出</p><p>​        可以输出高,低电平,连接数字器件; 推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中,各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。</p><img src="https://s1.ax1x.com/2020/06/17/NEfrAf.png" srcset="/img/loading.gif" alt="推挽输出结构图"  /><p>​        在该结构中输入高电平时，经过反向后，上方的P-MOS导通，下方的N-MOS关闭，对外输出高电平；而在该结构中输入低电平时，经过反向后，N-MOS管导通，P-MOS关闭，对外输出低电平。当引脚高低电平切换时，两个管子轮流导通，P管负责灌电流，N管负责拉电流，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的低电平为0伏，高电平为3.3伏</p></li><li><p>复用开漏输出</p><p>​        可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p></li><li><p>复用推挽输出</p><p>​        可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
