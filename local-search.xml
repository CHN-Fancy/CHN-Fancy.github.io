<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32串口通信</title>
    <link href="/2020/09/20/STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <url>/2020/09/20/STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1、USART"><a href="#1、USART" class="headerlink" title="1、USART"></a>1、USART</h1><h2 id="STM32串口通信数据格式"><a href="#STM32串口通信数据格式" class="headerlink" title="STM32串口通信数据格式"></a>STM32串口通信数据格式</h2><h3 id="STM32串口异步通信需要定义的参数："><a href="#STM32串口异步通信需要定义的参数：" class="headerlink" title="STM32串口异步通信需要定义的参数："></a>STM32串口异步通信需要定义的参数：</h3><ul><li>起始位：1个逻辑0数据位开始</li><li>数据位（8位或者9位）</li><li>奇偶校验位（第9位）</li><li>停止位（1,1.5,2位）</li><li>波特率设置</li></ul><h4 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h4><p><img src="https://s1.ax1x.com/2020/09/04/wkrEUf.png" alt="wkrEUf.png"></p><h2 id="STM32串口的设置流程"><a href="#STM32串口的设置流程" class="headerlink" title="STM32串口的设置流程"></a>STM32串口的设置流程</h2><p>​        STM32串口的一般配置流程还算比较简单的。只要你开启了<label style="color:yellow">黄色</label>，并设置相应的==IO口模式==，然后配置一下==波特率==，==数据位长==，==奇偶校验位==等信息就可以使用了。</p><p>​        其中配置串口的最基本设置，就是最波特率的设置，由于我们使用的芯片系统时钟不一样，所以我们要对不同系统时钟下的串口波特率进行设置。STM32中每个串口自己都有一个独立的波特率寄存器USART_BRR。STM32可以将系统时钟和波特率寄存器所代表的值相除得到我们想要的波特率。</p><p>​        这里， 我们简单介绍一下波特率的计算STM32F429 的串口波特率计算公式（OVER8=0）</p><script type="math/tex; mode=display">Tx/Rx波特率=\frac{f_{PCLKx}}{(16*USARTDIV)}</script><p>​        上式中，$f_{PCLKx}$是给串口的时钟（PCLK1用于UART2~5，UART7~8；PCLK2用于USART1和USART6）；USARTDIV是一个无符号的定点数（小数位不变的数叫顶点数）。我们只要得到USARTDIV的值，就可以得到串口波特率寄存器USARTx-&gt;BRR的值。下面我将介绍如何通过USARTDIV得到串口USART_BRR寄存器的值。假设我们的串口1要设置为115200的波特率，而PCLK2的时钟为90M。这样，我们根据上面的公式有：</p><script type="math/tex; mode=display">USARTDIV＝\frac{90000000}{115200*16}=48.828</script><p>那么得到：</p><p>​        DIV_Fration=16*0.828=9=0X0D</p><p>​        DIV_Mantissa=48=0X30</p><p>​        这样，我们就得到了USART1-&gt;BRR的值为0X30D。只要设置串口1的BRR寄存器值为0X30D就可以得到115200的波特率。</p><h3 id="设置数据位长、波特率、奇偶校验位及-初始化-代码如下："><a href="#设置数据位长、波特率、奇偶校验位及-初始化-代码如下：" class="headerlink" title="设置数据位长、波特率、奇偶校验位及==初始化==代码如下："></a>设置数据位长、波特率、奇偶校验位及==初始化==代码如下：</h3><p>寄存器版：</p><pre><code class="lang-C">void uart_init(u32 pclk2,u32 bound)&#123;           float temp;    u16 mantissa;    u16 fraction;           temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV@OVER8=0    mantissa=temp;                 //得到整数部分    fraction=(temp-mantissa)*16; //得到小数部分@OVER8=0     mantissa&lt;&lt;=4;    mantissa+=fraction;     RCC-&gt;AHB1ENR|=1&lt;&lt;0;       //使能PORTA时钟    RCC-&gt;APB2ENR|=1&lt;&lt;4;      //使能串口1时钟     GPIO_Set(GPIOA,PIN9|PIN10,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_50M,GPIO_PUPD_PU);//PA9,PA10,复用功能，上拉输出     GPIO_AF_Set(GPIOA,9,7);    //PA9,AF7    GPIO_AF_Set(GPIOA,10,7);//PA10,AF7             //波特率设置     USART1-&gt;BRR=mantissa;     //波特率设置         USART1-&gt;CR1&amp;=~(1&lt;&lt;15);     //设置OVER8=0     USART1-&gt;CR1|=1&lt;&lt;3;      //串口发送使能#if EN_USART1_RX              //如果使能了接收    //使能接收中断    USART1-&gt;CR1|=1&lt;&lt;2;      //串口接收使能    USART1-&gt;CR1|=1&lt;&lt;5;        //接收缓冲区非空中断使能    MY_NVIC_Init(3,3,USART1_IRQn,2);//组 2，最低优先级#endif    USART1-&gt;CR1|=1&lt;&lt;13;      //串口使能&#125;</code></pre><p>标准库版：</p><pre><code class="lang-C">void uart_init(u32 bound)&#123;   //GPIO 端口设置  GPIO_InitTypeDef GPIO_InitStructure;    USART_InitTypeDef USART_InitStructure;    NVIC_InitTypeDef NVIC_InitStructure;    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); //使能GPIOA时钟    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能USART1时钟    //串口1对应引脚复用映射    GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); //GPIOA9复用为USART1    GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1    //USART1端口配置  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    //速度50MHz    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉    GPIO_Init(GPIOA,&amp;GPIO_InitStructure); //初始化PA9，PA10   //USART1 初始化设置    USART_InitStructure.USART_BaudRate = bound;//波特率设置    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式    USART_InitStructure.USART_StopBits = USART_StopBits_1;//1个停止位    USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    //收发模式  USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1  USART_Cmd(USART1, ENABLE);  //使能串口1    //USART_ClearFlag(USART1, USART_FLAG_TC);#if EN_USART1_RX        USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启相关中断    //Usart1 NVIC 配置  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断通道    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;//抢占优先级3    NVIC_InitStructure.NVIC_IRQChannelSubPriority =3;        //子优先级3    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            //IRQ通道使能    NVIC_Init(&amp;NVIC_InitStructure);    //根据指定的参数初始化NVIC寄存器#endif&#125;</code></pre><h3 id="串口发送函数："><a href="#串口发送函数：" class="headerlink" title="串口发送函数："></a>串口发送函数：</h3><pre><code class="lang-C">void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)&#123;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));  assert_param(IS_USART_DATA(Data));   /* Transmit Data */  USARTx-&gt;DR = (Data &amp; (uint16_t)0x01FF);&#125;</code></pre><p>串口发送函数结合标志位的使用方法：</p><p><a href="https://blog.csdn.net/weibo1230123/article/details/80382150">STM32用USART发送字符串,以USART_FLAG_TXE和USART_FLAG_TC怎么用</a></p><h3 id="串口接收函数："><a href="#串口接收函数：" class="headerlink" title="串口接收函数："></a>串口接收函数：</h3><pre><code class="lang-C">uint16_t USART_ReceiveData(USART_TypeDef* USARTx)&#123;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));  /* Receive Data */C  return (uint16_t)(USARTx-&gt;DR &amp; (uint16_t)0x01FF);&#125;</code></pre><h3 id="Pritf函数重定义："><a href="#Pritf函数重定义：" class="headerlink" title="Pritf函数重定义："></a>Pritf函数重定义：</h3><p><a href="https://blog.csdn.net/linxi8693/article/details/88187460">STM32重写fputc</a></p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>串口通信</tag>
      
      <tag>USART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32中断控制</title>
    <link href="/2020/09/01/STM32%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/09/01/STM32%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="1、分类："><a href="#1、分类：" class="headerlink" title="1、分类："></a>1、分类：</h2><p>1、内核中断；</p><p><img src="https://s1.ax1x.com/2020/09/02/dzTnbR.png" alt="dzTnbR.png"></p><p>2、外部中断（可屏蔽中断）</p><p><img src="https://s1.ax1x.com/2020/09/02/dzTaVI.png" alt="dzTaVI.png"></p><h2 id="2、中断管理方法"><a href="#2、中断管理方法" class="headerlink" title="2、中断管理方法"></a>2、中断管理方法</h2><p>​        对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p><p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p><div class="table-container"><table><thead><tr><th style="text-align:center">组</th><th style="text-align:center">AIRCR[10:8]</th><th style="text-align:center">IP bit[7:4]</th><th style="text-align:center">分配结果</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">111</td><td style="text-align:center">0:4</td><td style="text-align:center">0位抢占优先级，4位响应优先级</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">110</td><td style="text-align:center">1:3</td><td style="text-align:center">1位抢占优先级，3位响应优先级</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">101</td><td style="text-align:center">2:2</td><td style="text-align:center">2位抢占优先级，2位响应优先级</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">100</td><td style="text-align:center">3:1</td><td style="text-align:center">3位抢占优先级，1位响应优先级</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">011</td><td style="text-align:center">4:0</td><td style="text-align:center">4位抢占优先级，0位响应优先级</td></tr></tbody></table></div><p>IP bit一共有4位所以一共可以给出16种不同的组合（级别）。</p><h2 id="3、优先级规则"><a href="#3、优先级规则" class="headerlink" title="3、优先级规则"></a>3、优先级规则</h2><ul><li>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。</li><li>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。（抢占优先级只负责打断进程，响应优先级只负责在两个中断同时发生的时候在抢占优先级相同的情况下哪个先执行，所以响应优先级高的不可进行打断）</li><li>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。</li><li>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</li></ul><p><strong>优先级的值越低，优先级的级别越高</strong>。</p><h3 id="举个栗："><a href="#举个栗：" class="headerlink" title="举个栗："></a>举个栗：</h3><p>假定设置中断优先级组为2，然后设置</p><div class="table-container"><table><thead><tr><th style="text-align:center">中断</th><th style="text-align:center">优先级设置</th></tr></thead><tbody><tr><td style="text-align:center">中断3（RTC中断）</td><td style="text-align:center">抢占优先级为2，响应优先级为1</td></tr><tr><td style="text-align:center">中断6（外部中断0）</td><td style="text-align:center">抢占优先级为3，响应优先级为0</td></tr><tr><td style="text-align:center">中断7（外部中断1）</td><td style="text-align:center">抢占优先级为2，响应优先级为0</td></tr></tbody></table></div><p>这3个中断的优先级顺序为：<strong>中断7&gt;中断3&gt;中断6</strong></p><h2 id="4、中断的优先级设置"><a href="#4、中断的优先级设置" class="headerlink" title="4、中断的优先级设置"></a>4、中断的优先级设置</h2><div class="table-container"><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">__IO uint8_t IP[240]</td><td style="text-align:center">中断优先级控制的寄存器组</td></tr><tr><td style="text-align:center">__IO uint32_t ISER[8]</td><td style="text-align:center">中断使能寄存器组</td></tr><tr><td style="text-align:center">__IO uint32_t ICER[8]</td><td style="text-align:center">中断失能寄存器组</td></tr><tr><td style="text-align:center">__IO uint32_t ISPR[8]</td><td style="text-align:center">中断挂起寄存器组</td></tr><tr><td style="text-align:center">__IO uint32_t ICPR[8]</td><td style="text-align:center">中断解挂寄存器组</td></tr><tr><td style="text-align:center">__IO uint32_t IABR[8]</td><td style="text-align:center">中断激活标志位寄存器组</td></tr></tbody></table></div><p><strong>中断优先级控制的寄存器组</strong>：IP[240]。全称是：Interrupt Priority Registers</p><p>​        240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F40x系列一共82个可屏蔽中断，使用IP[81]~IP[0]。</p><p>​        每个IP寄存器的<strong>高4位用来设置抢占和响应优先级</strong>（根据分组），低4位没有用到。</p><p>设置<strong>优先级</strong>方法：</p><p>​    调用函数</p><pre><code class="lang-C">void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);</code></pre><h2 id="5、中断优先级设置步骤"><a href="#5、中断优先级设置步骤" class="headerlink" title="5、中断优先级设置步骤"></a>5、中断优先级设置步骤</h2><ol><li><p>系统运行后在HAL_Init函数中设置中断优先级分组。调用函数：</p><pre><code class="lang-C"> HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);      //中断优先级分组2 整个系统执行过程中，只设置一次中断分组。</code></pre></li><li><p>针对每个中断，设置对应的抢占优先级和响应优先级：</p><pre><code class="lang-C">void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);</code></pre></li><li><p>使能中断通道：</p><pre><code class="lang-C">void HAL_NVIC_EnableIRQ(IRQn_Type IRQn);</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>中断</tag>
      
      <tag>NVIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO的八种工作模式</title>
    <link href="/2020/09/01/GPIO%E7%9A%84%E5%85%AB%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/09/01/GPIO%E7%9A%84%E5%85%AB%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="GPIO的八种工作模式"><a href="#GPIO的八种工作模式" class="headerlink" title="GPIO的八种工作模式"></a>GPIO的八种工作模式</h1><p>​        从GPIO（General-purpose input/output，通用输入/输出端口）的名称就能看出，其工作模式就分为两大类：输入、输出。</p><h2 id="输入模式（4种）"><a href="#输入模式（4种）" class="headerlink" title="输入模式（4种）"></a>输入模式（4种）</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">GPIO配置名称</th></tr></thead><tbody><tr><td style="text-align:center">模拟输入</td><td style="text-align:center">GPIO_Mode_AIN</td></tr><tr><td style="text-align:center">浮空输入</td><td style="text-align:center">GPIO_Mode_IN_FLOATING</td></tr><tr><td style="text-align:center">上拉输入</td><td style="text-align:center">GPIO_Mode_IPU</td></tr><tr><td style="text-align:center">下拉输入</td><td style="text-align:center">GPIO_Mode_IPD</td></tr></tbody></table></div><ol><li><p>模拟输入：</p><p>用于采集模拟信号的输入方式（ADC），或者低功耗下省电。</p></li><li><p>浮空输入：</p><p>对于浮空输入模式顾名思义也就是输入什么信号才是什么信号，对于浮空输入要保证有明确的输入信号（TTL或者CMOS标准）</p><blockquote><p>1）TTL</p><p>  供电范围在0~5V；如74系列都是5V供电</p><p>  对输出：大于2.7V是高电平；小于0.5V是低电平</p><p>  对输入：大于2V是高电平；小于0.8V是低电平</p><p>2) 3.3 LVTTL</p><p>  供电电压通常小等于3.3V</p><p>  对输出：大于2.0V是高电平；小于0.2V是低电平</p><p>  对输入：大于1.7V是高电平；小于0.7V是低电平</p><p>​    通常在许多处理器芯片都是用的LVTTL标准。</p></blockquote></li><li><p>上拉输入：</p><p>​    区别在于没有输入信号的时候默认输入高电平（因为有弱上拉）。外界还是可以接入低电平以实现低电平的读取。常用于数据传输线的配置。</p></li><li><p>下拉输入：</p><p>​    区别在于没有输入信号的时候默认输入低电平（因为有弱下拉）。外界还是可以接入高电平以实现高电平的读取。也常用于数据传输线的配置。</p></li></ol><h2 id="输出模式（4种）"><a href="#输出模式（4种）" class="headerlink" title="输出模式（4种）"></a>输出模式（4种）</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">GPIO配置名称</th></tr></thead><tbody><tr><td style="text-align:center">开漏输出</td><td style="text-align:center">GPIO_Mode_Out_OD</td></tr><tr><td style="text-align:center">推挽输出</td><td style="text-align:center">GPIO_Mode_Out_PP</td></tr><tr><td style="text-align:center">复用开漏输出</td><td style="text-align:center">GPIO_Mode_AF_OD</td></tr><tr><td style="text-align:center">复用推挽输出</td><td style="text-align:center">GPIO_Mode_AF_PP</td></tr></tbody></table></div><ol><li><p>开漏输出</p><p>​        输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).</p><p>​        OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。</p><p>​        可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。可以理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。</p></li><li><p>推挽输出</p><p>​        可以输出高,低电平,连接数字器件; 推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中,各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。</p><p><img src="https://s1.ax1x.com/2020/06/17/NEfrAf.png" alt="推挽输出结构图"  /></p><p>​        在该结构中输入高电平时，经过反向后，上方的P-MOS导通，下方的N-MOS关闭，对外输出高电平；而在该结构中输入低电平时，经过反向后，N-MOS管导通，P-MOS关闭，对外输出低电平。当引脚高低电平切换时，两个管子轮流导通，P管负责灌电流，N管负责拉电流，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的低电平为0伏，高电平为3.3伏</p></li><li><p>复用开漏输出</p><p>​        可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p></li><li><p>复用推挽输出</p><p>​        可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32位带操作笔记</title>
    <link href="/2020/09/01/STM32%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/09/01/STM32%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="寄存器位带操作"><a href="#寄存器位带操作" class="headerlink" title="寄存器位带操作"></a>寄存器位带操作</h1><h2 id="什么是位带操作？位操作？"><a href="#什么是位带操作？位操作？" class="headerlink" title="什么是位带操作？位操作？"></a>什么是位带操作？位操作？</h2><h3 id="位带操作："><a href="#位带操作：" class="headerlink" title="位带操作："></a>位带操作：</h3><p>​        通过位带区和位带别名区的地址映射关系可以直接访问寄存器的某一位，并向这一位写值（0或1）。</p><h3 id="普通的位操作：（使用“-amp-”，“-”指令来想、实现SRAM区域或者外设存储区进行位操作）"><a href="#普通的位操作：（使用“-amp-”，“-”指令来想、实现SRAM区域或者外设存储区进行位操作）" class="headerlink" title="普通的位操作：（使用“&amp;”，“|”指令来想、实现SRAM区域或者外设存储区进行位操作）"></a>普通的位操作：（使用“&amp;”，“|”指令来想、实现SRAM区域或者外设存储区进行位操作）</h3><p>​        由于STM32是按字节寻址的，所以并不能直接对位进行操作。若要想改变某个寄存器的值，须先通过寄存器的地址找到这个寄存器并读取寄存器的值，然后根据想要的功能修改读到的值，最后再将修改后的值写入寄存器中。</p><h2 id="位带操作的优越性在哪？"><a href="#位带操作的优越性在哪？" class="headerlink" title="位带操作的优越性在哪？"></a>位带操作的优越性在哪？</h2><p>​        相比于普通的位操作来说位带操作少了寄存器的读和修改的步骤，大大提升运行效率。</p><h2 id="什么是位带区什么是位带别名区？"><a href="#什么是位带区什么是位带别名区？" class="headerlink" title="什么是位带区什么是位带别名区？"></a>什么是位带区什么是位带别名区？</h2><h3 id="位带区："><a href="#位带区：" class="headerlink" title="位带区："></a>位带区：</h3><p>​        是寄存器真实存在的区域。每个寄存器都为4个字节（32位）。</p><h3 id="位带别名区："><a href="#位带别名区：" class="headerlink" title="位带别名区："></a>位带别名区：</h3><p>​        是位带区的对应的膨胀区域，可以想象成是一个位带区的映射。位带别名区的某一个字节的地址就对应相应位带区的某一位的地址，对位带别名区的一个字节进行操作就相当于是对位带区中某一位进行操作。</p><h2 id="为什么有的区域不支持位操作？"><a href="#为什么有的区域不支持位操作？" class="headerlink" title="为什么有的区域不支持位操作？"></a>为什么有的区域不支持位操作？</h2><p>​        是由Crotex-M3、C-M4或者其他系统架构所规定的。只要寄存器是属于位带区的，就支持位带操作。Crotex-M3中规定的支持位带操作的区域如下图所示。</p><p><img src="https://s1.ax1x.com/2020/07/27/aPmTBQ.jpg" alt="aPmTBQ.jpg"></p><p>分两块区域其中一块为SRAM中最低的1M，另一块为外设寄存器中最低的1M。</p><h3 id="位操作支持的区域"><a href="#位操作支持的区域" class="headerlink" title="位操作支持的区域"></a>位操作支持的区域</h3><p>另外在STM32F1xx和STM32F4xx上大部分的外设寄存器都支持位带操作，但少数外设寄存器并不支持位带操作。一位网友的经历，先来一个<a href="http://www.51hei.com/bbs/dpj-51883-1.html">链接</a>，以防文章被删留图存档。</p><p><img src="https://s1.ax1x.com/2020/07/27/aPupxf.png" alt="aPupxf.png"></p><h2 id="地址与位的关系（位带区与位带别名区的膨胀关系图）"><a href="#地址与位的关系（位带区与位带别名区的膨胀关系图）" class="headerlink" title="地址与位的关系（位带区与位带别名区的膨胀关系图）"></a>地址与位的关系（位带区与位带别名区的膨胀关系图）</h2><p><img src="https://s1.ax1x.com/2020/07/27/aPuqS0.png" alt="aPuqS0.png"></p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>GPIO</tag>
      
      <tag>位带操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
